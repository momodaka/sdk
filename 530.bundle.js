/*! For license information please see 530.bundle.js.LICENSE.txt */
(()=>{var e,r,t,i,n,o,a={5052:(e,r,t)=>{t.a(e,(async(e,i)=>{try{t.d(r,{AleoKeyProvider:()=>p,AleoKeyProviderParams:()=>h,ProgramManager:()=>d});var n=t(9933),o=e([n]);n=(o.then?(await o)():o)[0];async function a(e){const r=await fetch(e);if(!r.ok)throw new Error(r.status+" could not get URL "+e);return r}async function s(e,r){r.method="POST";const t=await fetch(e,r);if(!t.ok)throw new Error(t.status+" could not post URL "+e);return t}class f{host;account;constructor(e){this.host=e+"/testnet3"}setAccount(e){this.account=e}getAccount(){return this.account}setHost(e){this.host=e+"/testnet3"}async fetchData(e="/"){try{const r=await a(this.host+e);return await r.json()}catch(e){throw new Error("Error fetching data.")}}async findUnspentRecords(e,r,t,i,o,a){if(a=a||[],e<0)throw new Error("Start height must be greater than or equal to 0");const s=new Array;let c,u,l,f,h=0,p=BigInt(0);if(void 0===t){if(void 0===this.account)throw new Error("Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient");l=this.account._privateKey}else try{l=t instanceof n._q?t:n._q.from_string(t)}catch(e){throw new Error("Error parsing private key provided.")}const d=l.to_view_key();try{const e=await this.getLatestHeight();if("number"!=typeof e)throw new Error("Error fetching latest block height.");f=e}catch(e){throw new Error("Error fetching latest block height.")}if(u="number"==typeof r&&r<=f?r:f,e>u)throw new Error("Start height must be less than or equal to end height.");for(;u>e;){c=u-50,c<e&&(c=e);try{const e=await this.getBlockRange(c,u);if(u=c,!(e instanceof Error))for(let r=0;r<e.length;r++){const t=e[r].transactions;if(void 0!==t)for(let e=0;e<t.length;e++){const r=t[e];if("execute"==r.type){const e=r.transaction;if(e.execution&&void 0!==e.execution.transitions)for(let r=0;r<e.execution.transitions.length;r++){const t=e.execution.transitions[r];if("credits.aleo"===t.program&&void 0!==t.outputs)for(let e=0;e<t.outputs.length;e++){const r=t.outputs[e];if("record"===r.type)try{const e=n.fW.fromString(r.value);if(e.isOwner(d)){const r=e.decrypt(d),t=r.nonce();if(a.includes(t))continue;const n=r.serialNumberString(l,"credits.aleo","credits");try{await this.getTransitionId(n)}catch(e){if(!i&&(s.push(r),"number"==typeof o&&(p+=r.microcredits(),p>=BigInt(o))))return s;if(void 0!==i&&i.length>0){let e=0;if(r.microcredits()>i[e]){if(e+=1,s.push(r),"number"==typeof o&&(p+=r.microcredits(),p>=BigInt(o)))return s;if(s.length>=i.length)return s}}}}}catch(e){}}}}}}}catch(e){if(console.warn("Error fetching blocks in range: "+c.toString()+"-"+u.toString()),console.warn("Error: ",e),h+=1,h>10)return console.warn("10 failures fetching records reached. Returning records fetched so far"),s}}return s}async getBlock(e){try{return await this.fetchData("/block/"+e)}catch(e){throw new Error("Error fetching block.")}}async getBlockRange(e,r){try{return await this.fetchData("/blocks?start="+e+"&end="+r)}catch(t){throw new Error("Error fetching blocks between "+e+" and "+r+".")}}async getDeploymentTransactionIDForProgram(e){e instanceof n.$r&&(e=e.toString());try{return(await this.fetchData("/find/transactionID/deployment/"+e)).replace('"',"")}catch(e){throw new Error("Error fetching deployment transaction for program.")}}async getDeploymentTransactionForProgram(e){try{const r=await this.getDeploymentTransactionIDForProgram(e);return await this.getTransaction(r)}catch(e){throw new Error("Error fetching deployment transaction for program.")}}async getLatestBlock(){try{return await this.fetchData("/latest/block")}catch(e){throw new Error("Error fetching latest block.")}}async getLatestCommittee(){try{return await this.fetchData("/committee/latest")}catch(e){throw new Error("Error fetching latest block.")}}async getLatestHeight(){try{return await this.fetchData("/latest/height")}catch(e){throw new Error("Error fetching latest height.")}}async getProgram(e){try{return await this.fetchData("/program/"+e)}catch(e){throw new Error("Error fetching program")}}async getProgramObject(e){try{return n.$r.fromString(e)}catch(r){try{return n.$r.fromString(await this.getProgram(e))}catch(r){throw new Error(`${e} is neither a program name or a valid program`)}}}async getProgramImports(e){try{const r={},t=(e instanceof n.$r?e:await this.getProgramObject(e)).getImports();for(let e=0;e<t.length;e++){const i=t[e];if(!r.hasOwnProperty(i)){const e=await this.getProgram(i),t=await this.getProgramImports(i);for(const e in t)r.hasOwnProperty(e)||(r[e]=t[e]);r[i]=e}}return r}catch(e){throw l("Error fetching program imports: "+e)}}async getProgramImportNames(e){try{return(e instanceof n.$r?e:await this.getProgramObject(e)).getImports()}catch(e){throw new Error("Error fetching program imports with error: "+e)}}async getProgramMappingNames(e){try{return await this.fetchData("/program/"+e+"/mappings")}catch(e){throw new Error("Error fetching program mappings - ensure the program exists on chain before trying again")}}async getProgramMappingValue(e,r,t){try{return await this.fetchData("/program/"+e+"/mapping/"+r+"/"+t)}catch(e){throw new Error("Error fetching mapping value - ensure the mapping exists and the key is correct")}}async getStateRoot(){try{return await this.fetchData("/latest/stateRoot")}catch(e){throw new Error("Error fetching Aleo state root")}}async getTransaction(e){try{return await this.fetchData("/transaction/"+e)}catch(e){throw new Error("Error fetching transaction.")}}async getTransactions(e){try{return await this.fetchData("/block/"+e.toString()+"/transactions")}catch(e){throw new Error("Error fetching transactions.")}}async getTransactionsInMempool(){try{return await this.fetchData("/memoryPool/transactions")}catch(e){throw new Error("Error fetching transactions from mempool.")}}async getTransitionId(e){try{return await this.fetchData("/find/transitionID/"+e)}catch(e){throw new Error("Error fetching transition ID.")}}async submitTransaction(e){const r=e instanceof n.YW?e.toString():e;try{const e=await s(this.host+"/transaction/broadcast",{body:r,headers:{"Content-Type":"application/json"}});try{return await e.json()}catch(e){throw new Error(`Error posting transaction. Aleo network response: ${e.message}`)}}catch(e){throw new Error(`Error posting transaction: No response received: ${e.message}`)}}}class h{proverUri;verifierUri;cacheKey;constructor(e){this.proverUri=e.proverUri,this.verifierUri=e.verifierUri,this.cacheKey=e.cacheKey}}class p{cache;cacheOption;keyUris;async fetchBytes(e="/"){try{const r=await a(e),t=await r.arrayBuffer();return new Uint8Array(t)}catch(e){throw new Error("Error fetching data."+e)}}constructor(){this.keyUris=y,this.cache=new Map,this.cacheOption=!1}useCache(e){this.cacheOption=e}clearCache(){this.cache.clear()}cacheKeys(e,r){const[t,i]=r;this.cache.set(e,[t.toBytes(),i.toBytes()])}containsKeys(e){return this.cache.has(e)}deleteKeys(e){return this.cache.delete(e)}getKeys(e){if(console.debug(`Checking if key exists in cache. KeyId: ${e}`),this.cache.has(e)){const[r,t]=this.cache.get(e);return[n.zW.fromBytes(r),n.XV.fromBytes(t)]}return new Error("Key not found in cache.")}async functionKeys(e){if(e){let r,t,i;if("proverUri"in e&&"string"==typeof e.proverUri&&(r=e.proverUri),"verifierUri"in e&&"string"==typeof e.verifierUri&&(t=e.verifierUri),"cacheKey"in e&&"string"==typeof e.cacheKey&&(i=e.cacheKey),r&&t)return await this.fetchKeys(r,t,i);if(i)return this.getKeys(i)}throw Error("Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl")}async fetchKeys(e,r,t){try{if(this.cacheOption){t||(t=e);const i=this.cache.get(t);if(void 0!==i)return[n.zW.fromBytes(i[0]),n.XV.fromBytes(i[1])];{console.debug("Fetching proving keys from url "+e);const i=n.zW.fromBytes(await this.fetchBytes(e));console.debug("Fetching verifying keys "+r);const o=await this.getVerifyingKey(r);return this.cache.set(t,[i.toBytes(),o.toBytes()]),[i,o]}}{const t=n.zW.fromBytes(await this.fetchBytes(e));return[t,await this.getVerifyingKey(r)]}}catch(t){throw new Error(`Error: ${t} fetching fee proving and verifying keys from ${e} and ${r}.`)}}bondPublicKeys(){return this.fetchKeys(v.bond_public.prover,v.bond_public.verifier,v.bond_public.locator)}claimUnbondPublicKeys(){return this.fetchKeys(v.claim_unbond_public.prover,v.claim_unbond_public.verifier,v.claim_unbond_public.locator)}async transferKeys(e){if(w.has(e))return await this.fetchKeys(v.transfer_private.prover,v.transfer_private.verifier,v.transfer_private.locator);if(m.has(e))return await this.fetchKeys(v.transfer_private_to_public.prover,v.transfer_private_to_public.verifier,v.transfer_private_to_public.locator);if(_.has(e))return await this.fetchKeys(v.transfer_public.prover,v.transfer_public.verifier,v.transfer_public.locator);if(P.has(e))return await this.fetchKeys(v.transfer_public_to_private.prover,v.transfer_public_to_private.verifier,v.transfer_public_to_private.locator);throw new Error("Invalid visibility type")}async joinKeys(){return await this.fetchKeys(v.join.prover,v.join.verifier,v.join.locator)}async splitKeys(){return await this.fetchKeys(v.split.prover,v.split.verifier,v.split.locator)}async feePrivateKeys(){return await this.fetchKeys(v.fee_private.prover,v.fee_private.verifier,v.fee_private.locator)}async feePublicKeys(){return await this.fetchKeys(v.fee_public.prover,v.fee_public.verifier,v.fee_public.locator)}async getVerifyingKey(e){switch(e){case v.bond_public.verifier:return v.bond_public.verifyingKey();case v.claim_unbond_public.verifier:return v.claim_unbond_public.verifyingKey();case v.fee_private.verifier:return v.fee_private.verifyingKey();case v.fee_public.verifier:return v.fee_public.verifyingKey();case v.inclusion.verifier:return v.inclusion.verifyingKey();case v.join.verifier:return v.join.verifyingKey();case v.set_validator_state.verifier:return v.set_validator_state.verifyingKey();case v.split.verifier:return v.split.verifyingKey();case v.transfer_private.verifier:return v.transfer_private.verifyingKey();case v.transfer_private_to_public.verifier:return v.transfer_private_to_public.verifyingKey();case v.transfer_public.verifier:return v.transfer_public.verifyingKey();case v.transfer_public_to_private.verifier:return v.transfer_public_to_private.verifyingKey();case v.unbond_delegator_as_validator.verifier:return v.unbond_delegator_as_validator.verifyingKey();case v.unbond_public.verifier:return v.unbond_public.verifyingKey();default:try{const r=await a(e),t=await r.text();return n.XV.fromString(t)}catch(r){try{return n.XV.fromBytes(await this.fetchBytes(e))}catch(e){return new Error("Invalid verifying key. Error: "+e)}}}}unBondPublicKeys(){return this.fetchKeys(v.unbond_public.prover,v.unbond_public.verifier,v.unbond_public.locator)}}class d{account;keyProvider;host;networkClient;recordProvider;constructor(e,r,t){this.host=e||"https://api.explorer.aleo.org/v1",this.networkClient=new f(this.host),this.keyProvider=r||new p,this.recordProvider=t}setAccount(e){this.account=e}setKeyProvider(e){this.keyProvider=e}setHost(e){this.host=e,this.networkClient.setHost(e)}setRecordProvider(e){this.recordProvider=e}async deploy(e,r,t,i,o,a){try{const r=n.$r.fromString(e);let t;try{t=await this.networkClient.getProgram(r.id())}catch(e){console.log(`Program ${r.id()} does not exist on the network, deploying...`)}if("string"==typeof t)throw`Program ${r.id()} already exists on the network, please rename your program`}catch(e){throw l(`Error validating program: ${e}`)}let s,c=a;if(void 0===a&&void 0!==this.account&&(c=this.account.privateKey()),void 0===c)throw"No private key provided and no private key set in the ProgramManager";try{o=t?await this.getCreditsRecord(r,[],o,i):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{s=t?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[u,f]=s;let h;try{h=await this.networkClient.getProgramImports(e)}catch(e){throw l(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`)}const p=await n.L.buildDeploymentTransaction(c,e,r,o,this.host,h,u,f);return await this.networkClient.submitTransaction(p)}async buildExecutionTransaction(e){const{programName:r,functionName:t,fee:i,privateFee:o,inputs:a,recordSearchParams:s,keySearchParams:c,privateKey:u,offlineQuery:f}=e;let h=e.feeRecord,p=e.provingKey,d=e.verifyingKey,y=e.program,v=e.imports;if(void 0===y)try{y=await this.networkClient.getProgram(r)}catch(e){throw l(`Error finding ${r}. Network response: '${e}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`)}else y instanceof n.$r&&(y=y.toString());let g,b=u;if(void 0===u&&void 0!==this.account&&(b=this.account.privateKey()),void 0===b)throw"No private key provided and no private key set in the ProgramManager";try{h=o?await this.getCreditsRecord(i,[],h,s):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{g=o?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[w,m]=g;if(!p||!d)try{[p,d]=await this.keyProvider.functionKeys(c)}catch(e){console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`)}if(n.$r.fromString(y).getImports().length>0&&!v)try{v=await this.networkClient.getProgramImports(r)}catch(e){throw l(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`)}return await n.L.buildExecutionTransaction(b,y,t,a,i,h,this.host,v,p,d,w,m,f)}async execute(e){const r=await this.buildExecutionTransaction(e);return await this.networkClient.submitTransaction(r)}async run(e,r,t,i,o,a,s,c,u,l){let f=u;if(void 0===u&&void 0!==this.account&&(f=this.account.privateKey()),void 0===f)throw"No private key provided and no private key set in the ProgramManager";if(!s||!c)try{[s,c]=await this.keyProvider.functionKeys(a)}catch(e){console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`)}return console.log("Running program offline"),console.log("Proving key: ",s),console.log("Verifying key: ",c),n.L.executeFunctionOffline(f,e,r,t,i,!1,o,s,c,this.host,l)}async join(e,r,t,i,o,a,s,c){let u,f,h=s;if(void 0===s&&void 0!==this.account&&(h=this.account.privateKey()),void 0===h)throw"No private key provided and no private key set in the ProgramManager";try{u=i?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys(),f=await this.keyProvider.joinKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[p,d]=u,[y,v]=f;try{a=i?await this.getCreditsRecord(t,[],a,o):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{e=e instanceof n.PD?e:n.PD.fromString(e),r=r instanceof n.PD?r:n.PD.fromString(r)}catch(e){throw l("Records provided are not valid. Please ensure they are valid plaintext records.")}const g=await n.L.buildJoinTransaction(h,e,r,t,a,this.host,y,v,p,d,c);return await this.networkClient.submitTransaction(g)}async split(e,r,t,i){let o,a=t;if(void 0===a&&void 0!==this.account&&(a=this.account.privateKey()),void 0===a)throw"No private key provided and no private key set in the ProgramManager";try{o=await this.keyProvider.splitKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[s,c]=o;try{r=r instanceof n.PD?r:n.PD.fromString(r)}catch(e){throw l("Record provided is not valid. Please ensure it is a valid plaintext record.")}const u=await n.L.buildSplitTransaction(a,e,r,this.host,s,c,i);return await this.networkClient.submitTransaction(u)}async synthesizeKeys(e,r,t,i){let o,a=i;void 0===a&&(a=void 0!==this.account?this.account.privateKey():new n._q);try{o=await this.networkClient.getProgramImports(e);const i=await n.L.synthesizeKeyPair(a,e,r,t,o);return[i.provingKey(),i.verifyingKey()]}catch(e){throw l(`Could not synthesize keys - error ${e}. Please ensure the program is valid and the inputs are correct.`)}}async buildTransferTransaction(e,r,t,i,o,a,s,f,h,p){t=u(t);let d,y,v=h;if(void 0===v&&void 0!==this.account&&(v=this.account.privateKey()),void 0===v)throw"No private key provided and no private key set in the ProgramManager";try{d=o?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys(),y=await this.keyProvider.transferKeys(t)}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[g,b]=d,[w,m]=y;try{const e=[];c(t)?(s=await this.getCreditsRecord(i,[],s,a),e.push(s.nonce())):s=void 0,f=o?await this.getCreditsRecord(i,e,f,a):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}return await n.L.buildTransferTransaction(v,e,r,t,s,i,f,this.host,w,m,g,b,p)}async buildTransferPublicTransaction(e,r,t,i,n){return this.buildTransferTransaction(e,r,"public",t,!1,void 0,void 0,void 0,i,n)}async transfer(e,r,t,i,n,o,a,s,c,u){const l=await this.buildTransferTransaction(e,r,t,i,n,o,a,s,c,u);return await this.networkClient.submitTransaction(l)}async buildBondPublicTransaction(e,r,t={}){const i=Math.trunc(1e6*r),{programName:n="credits.aleo",functionName:o="bond_public",fee:a=t.fee||.86,privateFee:s=!1,inputs:c=[e,`${i.toString()}u64`],keySearchParams:u=new h({proverUri:v.bond_public.prover,verifierUri:v.bond_public.verifier,cacheKey:"credits.aleo/bond_public"}),program:l=this.creditsProgram(),...f}=t,p={programName:n,functionName:o,fee:a,privateFee:s,inputs:c,keySearchParams:u,...f};return await this.buildExecutionTransaction(p)}async bondPublic(e,r,t={}){const i=await this.buildBondPublicTransaction(e,r,t);return await this.networkClient.submitTransaction(i)}async buildUnbondPublicTransaction(e,r={}){const t=Math.trunc(1e6*e),{programName:i="credits.aleo",functionName:n="unbond_public",fee:o=r.fee||1.3,privateFee:a=!1,inputs:s=[`${t.toString()}u64`],keySearchParams:c=new h({proverUri:v.unbond_public.prover,verifierUri:v.unbond_public.verifier,cacheKey:"credits.aleo/unbond_public"}),program:u=this.creditsProgram(),...l}=r,f={programName:i,functionName:n,fee:o,privateFee:a,inputs:s,keySearchParams:c,...l};return this.buildExecutionTransaction(f)}async unbondPublic(e,r={}){const t=await this.buildUnbondPublicTransaction(e,r);return await this.networkClient.submitTransaction(t)}async buildClaimUnbondPublicTransaction(e={}){const{programName:r="credits.aleo",functionName:t="claim_unbond_public",fee:i=e.fee||2,privateFee:n=!1,inputs:o=[],keySearchParams:a=new h({proverUri:v.claim_unbond_public.prover,verifierUri:v.claim_unbond_public.verifier,cacheKey:"credits.aleo/claim_unbond_public"}),program:s=this.creditsProgram(),...c}=e,u={programName:r,functionName:t,fee:i,privateFee:n,inputs:o,keySearchParams:a,...c};return await this.buildExecutionTransaction(u)}async claimUnbondPublic(e={}){const r=await this.buildClaimUnbondPublicTransaction(e);return await this.networkClient.submitTransaction(r)}async setValidatorState(e,r={}){const{programName:t="credits.aleo",functionName:i="set_validator_state",fee:n=1,privateFee:o=!1,inputs:a=[e.toString()],keySearchParams:s=new h({proverUri:v.set_validator_state.prover,verifierUri:v.set_validator_state.verifier,cacheKey:"credits.aleo/set_validator_state"}),...c}=r,u={programName:t,functionName:i,fee:n,privateFee:o,inputs:a,keySearchParams:s,...c};return await this.execute(u)}async unbondDelegatorAsValidator(e,r={}){const{programName:t="credits.aleo",functionName:i="unbond_delegator_as_validator",fee:n=1,privateFee:o=!1,inputs:a=[e],keySearchParams:s=new h({proverUri:v.unbond_delegator_as_validator.prover,verifierUri:v.unbond_delegator_as_validator.verifier,cacheKey:"credits.aleo/unbond_delegator_as_validator"}),...c}=r,u={programName:t,functionName:i,fee:n,privateFee:o,inputs:a,keySearchParams:s,...c};return await this.execute(u)}verifyExecution(e){try{const r=e.getExecution(),t=e.getFunctionId(),i=e.getProgram(),o=e.getVerifyingKey();return(0,n.hz)(r,o,i,t)}catch(e){return console.warn("The execution was not found in the response, cannot verify the execution"),!1}}createProgramFromSource(e){return n.$r.fromString(e)}creditsProgram(){return n.$r.getCreditsProgram()}verifyProgram(e){try{return n.$r.fromString(e),!0}catch(e){return!1}}async getCreditsRecord(e,r,t,i){try{return t instanceof n.PD?t:n.PD.fromString(t)}catch(t){try{const t=this.recordProvider;return await t.findCreditsRecord(e,!0,r,i)}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}}}}function c(e){return g.has(e)}function u(e){return b.has(e)?e:l(`Invalid transfer type '${e}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`)}const y="https://testnet3.parameters.aleo.org/",v={bond_public:{locator:"credits.aleo/bond_public",prover:y+"bond_public.prover.9c3547d",verifier:"bond_public.verifier.10315ae",verifyingKey:n.XV.bondPublicVerifier},claim_unbond_public:{locator:"credits.aleo/claim_unbond_public",prover:y+"claim_unbond_public.prover.f8b64aa",verifier:"claim_unbond_public.verifier.8fd7445",verifyingKey:n.XV.claimUnbondPublicVerifier},fee_private:{locator:"credits.aleo/fee_private",prover:y+"fee_private.prover.43fab98",verifier:"fee_private.verifier.f3dfefc",verifyingKey:n.XV.feePrivateVerifier},fee_public:{locator:"credits.aleo/fee_public",prover:y+"fee_public.prover.634f153",verifier:"fee_public.verifier.09eeb4f",verifyingKey:n.XV.feePublicVerifier},inclusion:{locator:"inclusion",prover:y+"inclusion.prover.cd85cc5",verifier:"inclusion.verifier.e6f3add",verifyingKey:n.XV.inclusionVerifier},join:{locator:"credits.aleo/join",prover:y+"join.prover.1a76fe8",verifier:"join.verifier.4f1701b",verifyingKey:n.XV.joinVerifier},set_validator_state:{locator:"credits.aleo/set_validator_state",prover:y+"set_validator_state.prover.5ce19be",verifier:"set_validator_state.verifier.730d95b",verifyingKey:n.XV.setValidatorStateVerifier},split:{locator:"credits.aleo/split",prover:y+"split.prover.e6d12b9",verifier:"split.verifier.2f9733d",verifyingKey:n.XV.splitVerifier},transfer_private:{locator:"credits.aleo/transfer_private",prover:y+"transfer_private.prover.2b487c0",verifier:"transfer_private.verifier.3a3cbba",verifyingKey:n.XV.transferPrivateVerifier},transfer_private_to_public:{locator:"credits.aleo/transfer_private_to_public",prover:y+"transfer_private_to_public.prover.1ff64cb",verifier:"transfer_private_to_public.verifier.d5b60de",verifyingKey:n.XV.transferPrivateToPublicVerifier},transfer_public:{locator:"credits.aleo/transfer_public",prover:y+"transfer_public.prover.a74565e",verifier:"transfer_public.verifier.a4c2906",verifyingKey:n.XV.transferPublicVerifier},transfer_public_to_private:{locator:"credits.aleo/transfer_public_to_private",prover:y+"transfer_public_to_private.prover.1bcddf9",verifier:"transfer_public_to_private.verifier.b094554",verifyingKey:n.XV.transferPublicToPrivateVerifier},unbond_delegator_as_validator:{locator:"credits.aleo/unbond_delegator_as_validator",prover:y+"unbond_delegator_as_validator.prover.115a86b",verifier:"unbond_delegator_as_validator.verifier.9585609",verifyingKey:n.XV.unbondDelegatorAsValidatorVerifier},unbond_public:{locator:"credits.aleo/unbond_public",prover:y+"unbond_public.prover.9547c05",verifier:"unbond_public.verifier.09873cd",verifyingKey:n.XV.unbondPublicVerifier}},g=new Set(["transfer_private","private","transferPrivate","transfer_private_to_public","privateToPublic","transferPrivateToPublic"]),b=new Set(["transfer_private","private","transferPrivate","transfer_private_to_public","privateToPublic","transferPrivateToPublic","transfer_public","public","transferPublic","transfer_public_to_private","publicToPrivate","transferPublicToPrivate"]),w=new Set(["private","transfer_private","transferPrivate"]),m=new Set(["private_to_public","privateToPublic","transfer_private_to_public","transferPrivateToPublic"]),_=new Set(["public","transfer_public","transferPublic"]),P=new Set(["public_to_private","publicToPrivate","transfer_public_to_private","transferPublicToPrivate"]);function l(e){throw console.error(e),e}i()}catch(k){i(k)}}))},9669:(e,r,t)=>{t.a(e,(async(e,r)=>{try{var i=t(5052),n=t(6891),o=t(9933),a=e([i,o]);[i,o]=a.then?(await a)():a,await(0,o.CK)();const u="https://api.explorer.aleo.org/v1",l=new i.AleoKeyProvider,f=new i.ProgramManager(u,l,void 0);l.useCache(!0);let h="";async function s(e,r,t,n,a=!1){console.log("Web worker: Executing function locally...");const s=performance.now();try{const c=f.createProgramFromSource(e);if(c instanceof Error)throw"Error creating program from source";const u=c.id();if(!c.hasFunction(r))throw`Program ${u} does not contain function ${r}`;const p=`${u}:${r}`,d=await f.networkClient.getProgramImports(e);if(d instanceof Error)throw"Error getting program imports";if(h!==e){const i=await f.synthesizeKeys(e,r,t,o._q.from_string(n));f.keyProvider.cacheKeys(p,i),h=e}const y=new i.AleoKeyProviderParams({cacheKey:p}),v=await f.run(e,r,t,a,d,y,void 0,void 0,o._q.from_string(n));console.log(`Web worker: Local execution completed in ${performance.now()-s} ms`);const g=v.getOutputs(),b=v.getExecution();let w="";const m=l.getKeys(p);if(m instanceof Error)throw"Could not get verifying key";const _=m[1];return b?((0,o.hz)(b,_,c,"hello"),w=b.toString(),console.log("Execution verified successfully: "+b)):w="",console.log(`Function execution response: ${g}`),{outputs:g,execution:w}}catch(e){return console.error(e),e?e.toString():"Unknown error"}}async function c(){return(new o._q).to_string()}const p={executeOffline:s,getPrivateKey:c};(0,n.Jj)(p),r()}catch(d){r(d)}}),1)},6891:(e,r,t)=>{t.d(r,{Jj:()=>l});const i=Symbol("Comlink.proxy"),n=Symbol("Comlink.endpoint"),o=Symbol("Comlink.releaseProxy"),a=Symbol("Comlink.finalizer"),s=Symbol("Comlink.thrown"),c=e=>"object"==typeof e&&null!==e||"function"==typeof e,u=new Map([["proxy",{canHandle:e=>c(e)&&e[i],serialize(e){const{port1:r,port2:t}=new MessageChannel;return l(e,r),[t,[t]]},deserialize(e){return e.start(),v(e,[],r);var r}}],["throw",{canHandle:e=>c(e)&&s in e,serialize({value:e}){let r;return r=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[r,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function l(e,r=globalThis,t=["*"]){r.addEventListener("message",(function n(o){if(!o||!o.data)return;if(!function(e,r){for(const t of e){if(r===t||"*"===t)return!0;if(t instanceof RegExp&&t.test(r))return!0}return!1}(t,o.origin))return void console.warn(`Invalid origin '${o.origin}' for comlink proxy`);const{id:c,type:u,path:h}=Object.assign({path:[]},o.data),p=(o.data.argumentList||[]).map(m);let d;try{const r=h.slice(0,-1).reduce(((e,r)=>e[r]),e),t=h.reduce(((e,r)=>e[r]),e);switch(u){case"GET":d=t;break;case"SET":r[h.slice(-1)[0]]=m(o.data.value),d=!0;break;case"APPLY":d=t.apply(r,p);break;case"CONSTRUCT":d=function(e){return Object.assign(e,{[i]:!0})}(new t(...p));break;case"ENDPOINT":{const{port1:r,port2:t}=new MessageChannel;l(e,t),d=function(e,r){return b.set(e,r),e}(r,[r])}break;case"RELEASE":d=void 0;break;default:return}}catch(e){d={value:e,[s]:0}}Promise.resolve(d).catch((e=>({value:e,[s]:0}))).then((t=>{const[i,o]=w(t);r.postMessage(Object.assign(Object.assign({},i),{id:c}),o),"RELEASE"===u&&(r.removeEventListener("message",n),f(r),a in e&&"function"==typeof e[a]&&e[a]())})).catch((e=>{const[t,i]=w({value:new TypeError("Unserializable return value"),[s]:0});r.postMessage(Object.assign(Object.assign({},t),{id:c}),i)}))})),r.start&&r.start()}function f(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function h(e){if(e)throw new Error("Proxy has been released and is not useable")}function p(e){return _(e,{type:"RELEASE"}).then((()=>{f(e)}))}const d=new WeakMap,y="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const r=(d.get(e)||0)-1;d.set(e,r),0===r&&p(e)}));function v(e,r=[],t=function(){}){let i=!1;const a=new Proxy(t,{get(t,n){if(h(i),n===o)return()=>{!function(e){y&&y.unregister(e)}(a),p(e),i=!0};if("then"===n){if(0===r.length)return{then:()=>a};const t=_(e,{type:"GET",path:r.map((e=>e.toString()))}).then(m);return t.then.bind(t)}return v(e,[...r,n])},set(t,n,o){h(i);const[a,s]=w(o);return _(e,{type:"SET",path:[...r,n].map((e=>e.toString())),value:a},s).then(m)},apply(t,o,a){h(i);const s=r[r.length-1];if(s===n)return _(e,{type:"ENDPOINT"}).then(m);if("bind"===s)return v(e,r.slice(0,-1));const[c,u]=g(a);return _(e,{type:"APPLY",path:r.map((e=>e.toString())),argumentList:c},u).then(m)},construct(t,n){h(i);const[o,a]=g(n);return _(e,{type:"CONSTRUCT",path:r.map((e=>e.toString())),argumentList:o},a).then(m)}});return function(e,r){const t=(d.get(r)||0)+1;d.set(r,t),y&&y.register(e,r,e)}(a,e),a}function g(e){const r=e.map(w);return[r.map((e=>e[0])),(t=r.map((e=>e[1])),Array.prototype.concat.apply([],t))];var t}const b=new WeakMap;function w(e){for(const[r,t]of u)if(t.canHandle(e)){const[i,n]=t.serialize(e);return[{type:"HANDLER",name:r,value:i},n]}return[{type:"RAW",value:e},b.get(e)||[]]}function m(e){switch(e.type){case"HANDLER":return u.get(e.name).deserialize(e.value);case"RAW":return e.value}}function _(e,r,t){return new Promise((i=>{const n=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function r(t){t.data&&t.data.id&&t.data.id===n&&(e.removeEventListener("message",r),i(t.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:n},r),t)}))}}},s={};function c(e){var r=s[e];if(void 0!==r)return r.exports;var t=s[e]={exports:{}};return a[e](t,t.exports,c),t.exports}c.m=a,c.x=()=>{var e=c.O(void 0,[933],(()=>c(9669)));return e=c.O(e)},e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",r="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",t="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",i=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},c.a=(n,o,a)=>{var s;a&&((s=[]).d=-1);var c,u,l,f=new Set,h=n.exports,p=new Promise(((e,r)=>{l=r,u=e}));p[r]=h,p[e]=e=>(s&&e(s),f.forEach(e),p.catch((e=>{}))),n.exports=p,o((n=>{var o;c=(n=>n.map((n=>{if(null!==n&&"object"==typeof n){if(n[e])return n;if(n.then){var o=[];o.d=0,n.then((e=>{a[r]=e,i(o)}),(e=>{a[t]=e,i(o)}));var a={};return a[e]=e=>e(o),a}}var s={};return s[e]=e=>{},s[r]=n,s})))(n);var a=()=>c.map((e=>{if(e[t])throw e[t];return e[r]})),u=new Promise((r=>{(o=()=>r(a)).r=0;var t=e=>e!==s&&!f.has(e)&&(f.add(e),e&&!e.d&&(o.r++,e.push(o)));c.map((r=>r[e](t)))}));return o.r?u:a()}),(e=>(e?l(p[t]=e):u(h),i(s)))),s&&s.d<0&&(s.d=0)},n=[],c.O=(e,r,t,i)=>{if(!r){var o=1/0;for(l=0;l<n.length;l++){for(var[r,t,i]=n[l],a=!0,s=0;s<r.length;s++)(!1&i||o>=i)&&Object.keys(c.O).every((e=>c.O[e](r[s])))?r.splice(s--,1):(a=!1,i<o&&(o=i));if(a){n.splice(l--,1);var u=t();void 0!==u&&(e=u)}}return e}i=i||0;for(var l=n.length;l>0&&n[l-1][2]>i;l--)n[l]=n[l-1];n[l]=[r,t,i]},c.d=(e,r)=>{for(var t in r)c.o(r,t)&&!c.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},c.f={},c.e=e=>Promise.all(Object.keys(c.f).reduce(((r,t)=>(c.f[t](e,r),r)),[])),c.u=e=>e+".bundle.js",c.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),c.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),(()=>{var e;c.g.importScripts&&(e=c.g.location+"");var r=c.g.document;if(!e&&r&&(r.currentScript&&(e=r.currentScript.src),!e)){var t=r.getElementsByTagName("script");if(t.length)for(var i=t.length-1;i>-1&&!e;)e=t[i--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),c.p=e})(),(()=>{c.b=self.location+"";var e={530:1};c.f.i=(r,t)=>{e[r]||importScripts(c.p+c.u(r))};var r=self.webpackChunkaleo_website=self.webpackChunkaleo_website||[],t=r.push.bind(r);r.push=r=>{var[i,n,o]=r;for(var a in n)c.o(n,a)&&(c.m[a]=n[a]);for(o&&o(c);i.length;)e[i.pop()]=1;t(r)}})(),o=c.x,c.x=()=>c.e(933).then(o);c.x()})();
//# sourceMappingURL=530.bundle.js.map